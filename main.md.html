<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Felicitas Pojtinger" />
  <title>Uni Algodat Notes</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Uni Algodat Notes</h1>
<p class="author">Felicitas Pojtinger</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#uni-algodat-notes">Uni Algodat Notes</a>
<ul>
<li><a href="#themen">Themen</a></li>
<li><a href="#paradigm-conversion">Paradigm Conversion</a></li>
<li><a href="#begriffe">Begriffe</a></li>
<li><a href="#eigenschaften-von-algorithmen">Eigenschaften von Algorithmen</a></li>
<li><a href="#zeitkomplexität">Zeitkomplexität</a>
<ul>
<li><a href="#wichtige-wachstumsfunktionen">Wichtige Wachstumsfunktionen</a></li>
<li><a href="#sortieralgorithmen">Sortieralgorithmen</a></li>
</ul></li>
<li><a href="#adts">ADTs</a>
<ul>
<li><a href="#übersicht">Übersicht</a></li>
<li><a href="#stack">Stack</a></li>
<li><a href="#queue">Queue</a></li>
<li><a href="#binärbaum">Binärbaum</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="uni-algodat-notes">Uni Algodat Notes</h1>
<h2 id="themen">Themen</h2>
<ul>
<li>Einleitung
<ul>
<li>Zyklus der Informationsverarbeitung</li>
<li>Grundbegriffe zu Algodat</li>
<li>Eigenschaften von Algorithmen</li>
</ul></li>
<li>Zeitkomplexität
<ul>
<li>Problemgröße des Inputs</li>
<li>Schrittzahlfunktionen</li>
<li>Testfunktionen</li>
<li>Best Case &amp; Worst Case</li>
<li>Beispiele
<ul>
<li>Suche im Binärbaum</li>
<li>Fibonacci-Sequenz</li>
<li>Bubble-Sort</li>
</ul></li>
</ul></li>
<li>Applikative Algorithmen
<ul>
<li>Definition Algorithmus</li>
<li>Schritte des Auswertung</li>
<li>Rekursion</li>
</ul></li>
<li>Sortieralgorithmen
<ul>
<li>Merge-Sort
<ul>
<li>Zeitkomplexität</li>
</ul></li>
<li>Quicksort
<ul>
<li>Pivot-Element</li>
<li>Zeitkomplexität</li>
</ul></li>
</ul></li>
<li>Abstrakte Datentypen
<ul>
<li>ADT</li>
<li>Stacks</li>
<li>Queues</li>
<li>Binärbäume</li>
</ul></li>
<li>Binäre Bäume
<ul>
<li>Implementation BinaryTree</li>
<li>Suchbäume
<ul>
<li>Definition</li>
<li>Zeitkomplexität</li>
</ul></li>
</ul></li>
<li>AVL-Bäume
<ul>
<li>Definition</li>
<li>Balancing</li>
<li>Doppelte Relation</li>
<li>Zeitkomplexität</li>
</ul></li>
</ul>
<h2 id="paradigm-conversion">Paradigm Conversion</h2>
<p>I’m too stupid to write proper functional code, so most of the times I “convert” my imperative solutions to functional ones using the following schema I found on the web:</p>
<ol type="1">
<li>Isolate the loop in its own function. Make sure that all captured variables (i.e., variables that are used in the loop, but not declared in the loop) are passed in as parameters.</li>
<li>If the loop declares its own counter (e.g., in a for-loop), remove that declaration and make the loop counter another parameter.</li>
<li>Replace the loop construct itself:
<ol type="1">
<li>Replace the loop condition check with an if statement (or if expression, if that’s what your language has).</li>
<li>In the failure branch, return.</li>
<li>Move the rest of the loop code into the success branch.</li>
<li>At the end of the success branch, add a recursive call which passes the modified values of the loop counter and all captured variables; this is equivalent to the jump back to the top of the original loop.</li>
</ol></li>
<li>At the original site of the loop, put in a call to your new recursive function. This is where you’ll now provide the initial value of the loop counter.</li>
<li>Perform whatever other optimizations seem obvious, as the code at this point will be functional, but probably ugly, probably inefficient, and probably unidiomatic.</li>
</ol>
<h2 id="begriffe">Begriffe</h2>
<ul>
<li><strong>Algorithmus</strong>: Präzise, endliche Beschreibung eines allgemeinen Verfahrens unter Verwendung ausführbarer, elementarer Schritte</li>
<li><strong>Daten</strong>: Von Maschinen verarbeitbare Form von Infos</li>
<li><strong>Datenstruktur</strong>: Von Maschinen verarbeitbarer struktureller Rahmen für die Darstellung von Daten</li>
<li><strong>Programm</strong>: Formulierung eines oder mehrerer Algorithmen und Datenstrukturen durch Programmiersprache</li>
</ul>
<h2 id="eigenschaften-von-algorithmen">Eigenschaften von Algorithmen</h2>
<ul>
<li><strong>Terminierend</strong>: Bricht bei jeder (erlaubten) Eingabe nach endlich vielen Schritten ab</li>
<li><strong>Determiniertes Ergebnis</strong>: Liefert bei selber (erlaubter) Eingabe immer dasselbe Ergebnis</li>
<li><strong>Determinierter Ablauf</strong>: Führt bei selber (erlaubter) Eingabe immer die Schritte in derselben Reihenfolge aus</li>
<li><strong>Deterministisch</strong>: Determiniertes Ergebnis &amp; determinierter Ablauf</li>
<li><strong>Zeitkomplexität</strong>: Wachstumsverhalten der benötigten Anzahl von Schritten, wenn Problemgröße gegen unendlich strebt</li>
</ul>
<h2 id="zeitkomplexität">Zeitkomplexität</h2>
<ol type="1">
<li>Ausgangspunkt: Algorithmus <span class="math inline"><em>A</em></span></li>
<li>Finde ein Maß für die Problemgröße des Inputs
<ul>
<li><strong>Sortieren einer Liste</strong>: <span class="math inline"><em>N</em> = <em>A</em><em>n</em><em>z</em><em>a</em><em>h</em><em>l</em> <em>E</em><em>l</em><em>e</em><em>m</em><em>e</em><em>n</em><em>t</em><em>e</em> <em>d</em><em>e</em><em>r</em> <em>L</em><em>i</em><em>s</em><em>t</em><em>e</em></span></li>
<li><strong>Bäume</strong>: <span class="math inline"><em>N</em> = <em>A</em><em>n</em><em>z</em><em>a</em><em>h</em><em>l</em> <em>K</em><em>n</em><em>o</em><em>t</em><em>e</em><em>n</em></span></li>
<li><strong>Textsuche</strong>: <span class="math inline"><em>N</em> = <em>A</em><em>n</em><em>z</em><em>a</em><em>h</em><em>l</em> <em>Z</em><em>e</em><em>i</em><em>c</em><em>h</em><em>e</em><em>n</em> <em>i</em><em>m</em> <em>T</em><em>e</em><em>x</em><em>t</em></span></li>
</ul></li>
<li>Finde die Anzahl der signifikanten Schritte von <span class="math inline"><em>A</em></span> bei Problemgröße <span class="math inline"><em>N</em></span>.</li>
<li>Bestimme das Wachstumsverhalten der Funktion für <span class="math inline"><em>N</em> → ∞</span></li>
<li>Vergleiche Funktion mit <span class="math inline"><em>t</em>(<em>N</em>)</span> und finde <em>richtiges</em> Wachstumsverhalten.</li>
</ol>
<h3 id="wichtige-wachstumsfunktionen">Wichtige Wachstumsfunktionen</h3>
<ul>
<li><strong>Bäume</strong>: <span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em>(<em>n</em>))</span></li>
<li><strong>Binary Search</strong>: <span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em>(<em>n</em>))</span></li>
<li><strong>Merge Sort</strong>: <span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em>(<em>n</em>))</span> (Out-of-Place)</li>
<li><strong>Quicksort</strong>: <span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em>(<em>n</em>))</span> (In-Place)</li>
<li><strong>Bubble Sort</strong>: <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>
</ul>
<h3 id="sortieralgorithmen">Sortieralgorithmen</h3>
<ul>
<li><strong>In-Place</strong>: Es wird (nahezu) kein weiterer Speicher bei der Ausführung gebraucht (i.e. Quicksort)</li>
<li><strong>Out-of-Place</strong>: Es wird zusätzlicher Speicher bei der Ausführung gebraucht (i.e. Merge Sort)</li>
</ul>
<h2 id="adts">ADTs</h2>
<h3 id="übersicht">Übersicht</h3>
<ul>
<li>Abstrakte Datentypen als Vorläufer der Klassen in OOP</li>
<li>ADT: Mehrfach instanziierbares Software-Modul</li>
<li>Jede Instanz hat ein Interface</li>
<li>Syntax für Operatoren: <code>&lt;op_name&gt;: &lt;arg1&gt; [x arg2...] → &lt;return_type&gt;</code></li>
</ul>
<h3 id="stack">Stack</h3>
<ul>
<li><p><strong>type</strong> <span class="math inline"><em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>)</span></p></li>
<li><p><strong>sorts</strong>: <span class="math inline"><em>T</em>, <em>b</em><em>o</em><em>o</em><em>l</em></span></p></li>
<li><p><strong>operations</strong></p>
<ul>
<li><strong>new</strong>: <span class="math inline"><em>ø</em> → <em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>)</span></li>
<li><strong>push</strong>: <span class="math inline"><em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>)<em>x</em><em>T</em> → <em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>)</span></li>
<li><strong>pop</strong>: <span class="math inline"><em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>) → <em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>)</span></li>
<li><strong>top</strong>: <span class="math inline"><em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>) → <em>T</em></span></li>
<li><strong>empty</strong>: <span class="math inline"><em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>) → <em>b</em><em>o</em><em>o</em><em>l</em></span></li>
</ul></li>
<li><p><strong>axioms</strong></p>
<ul>
<li><span class="math inline"><em>p</em><em>o</em><em>p</em>(<em>p</em><em>u</em><em>s</em><em>h</em>(<em>s</em>,<em>t</em>)) = <em>s</em></span></li>
<li><span class="math inline"><em>t</em><em>o</em><em>p</em>(<em>p</em><em>u</em><em>s</em><em>h</em>(<em>s</em>,<em>t</em>)) = <em>t</em></span></li>
<li><span class="math inline"><em>e</em><em>m</em><em>p</em><em>t</em><em>y</em>(<em>n</em><em>e</em><em>w</em>(())) = <em>t</em><em>r</em><em>u</em><em>e</em></span></li>
<li><span class="math inline"><em>e</em><em>m</em><em>p</em><em>t</em><em>y</em>(<em>p</em><em>u</em><em>s</em><em>h</em>(<em>s</em>,<em>t</em>)) = <em>f</em><em>a</em><em>l</em><em>s</em><em>e</em></span></li>
</ul></li>
</ul>
<h3 id="queue">Queue</h3>
<ul>
<li><strong>type</strong> <span class="math inline"><em>Q</em><em>u</em><em>e</em><em>u</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>sorts</strong> <span class="math inline"><em>T</em>, <em>b</em><em>o</em><em>o</em><em>l</em></span></li>
<li><strong>operations</strong>
<ul>
<li><strong>new</strong>: <span class="math inline"><em>ø</em> → <em>Q</em><em>u</em><em>e</em><em>u</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>enter</strong>: <span class="math inline"><em>Q</em><em>u</em><em>e</em><em>u</em><em>e</em>(<em>T</em>)<em>x</em><em>T</em> → <em>Q</em><em>u</em><em>e</em><em>u</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>leave</strong>: <span class="math inline"><em>Q</em><em>u</em><em>e</em><em>u</em><em>e</em>(<em>T</em>) → <em>Q</em><em>u</em><em>e</em><em>u</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>head</strong>: <span class="math inline"><em>Q</em><em>u</em><em>e</em><em>u</em><em>e</em>(<em>T</em>) → <em>T</em></span></li>
<li><strong>empty</strong>: <span class="math inline"><em>S</em><em>t</em><em>a</em><em>c</em><em>k</em>(<em>T</em>) → <em>b</em><em>o</em><em>o</em><em>l</em></span></li>
</ul></li>
<li><strong>axioms</strong>
<ul>
<li><span class="math inline"><em>e</em><em>m</em><em>p</em><em>t</em><em>y</em>(<em>n</em><em>e</em><em>w</em>()) = <em>t</em><em>r</em><em>u</em><em>e</em></span></li>
<li><span class="math inline"><em>h</em><em>e</em><em>a</em><em>d</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>n</em><em>e</em><em>w</em>(),<em>t</em>)) = <em>t</em></span></li>
<li><span class="math inline"><em>l</em><em>e</em><em>a</em><em>v</em><em>e</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>n</em><em>e</em><em>w</em>(),<em>t</em>)) = <em>n</em><em>e</em><em>w</em>()</span></li>
<li><span class="math inline"><em>l</em><em>e</em><em>a</em><em>v</em><em>e</em>(<em>n</em><em>e</em><em>w</em>()) = <em>n</em><em>e</em><em>w</em>()</span></li>
<li><span class="math inline"><em>h</em><em>e</em><em>a</em><em>d</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>q</em>,<em>s</em>),<em>t</em>)) = <em>h</em><em>e</em><em>a</em><em>d</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>q</em>,<em>s</em>))</span></li>
<li><span class="math inline"><em>l</em><em>e</em><em>a</em><em>v</em><em>e</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>q</em>,<em>s</em>),<em>t</em>)) = <em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>l</em><em>e</em><em>a</em><em>v</em><em>e</em>(<em>e</em><em>n</em><em>t</em><em>e</em><em>r</em>(<em>q</em>,<em>s</em>)),<em>t</em>)</span></li>
</ul></li>
</ul>
<h3 id="binärbaum">Binärbaum</h3>
<ul>
<li><strong>type</strong> <span class="math inline"><em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>sort</strong> <span class="math inline"><em>T</em>, <em>b</em><em>o</em><em>o</em><em>l</em></span></li>
<li><strong>operations</strong>
<ul>
<li><strong>new</strong>: <span class="math inline"><em>ø</em> → <em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>bin</strong>: <span class="math inline"><em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>)<em>x</em><em>T</em><em>x</em><em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>) → <em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>left</strong>: <span class="math inline"><em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>) → <em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>right</strong>: <span class="math inline"><em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>) → <em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>)</span></li>
<li><strong>root</strong>: <span class="math inline"><em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>) → <em>T</em></span></li>
<li><strong>empty</strong>: <span class="math inline"><em>B</em><em>i</em><em>n</em><em>T</em><em>r</em><em>e</em><em>e</em>(<em>T</em>) → <em>b</em><em>o</em><em>o</em><em>l</em></span></li>
</ul></li>
<li><strong>axioms</strong>
<ul>
<li><span class="math inline"><em>l</em><em>e</em><em>f</em><em>t</em>(<em>b</em><em>i</em><em>n</em>(<em>x</em>,<em>t</em>,<em>y</em>)) = <em>x</em></span></li>
<li><span class="math inline"><em>r</em><em>i</em><em>g</em><em>h</em><em>t</em>(<em>b</em><em>i</em><em>n</em>(<em>x</em>,<em>t</em>,<em>y</em>)) = <em>y</em></span></li>
<li><span class="math inline"><em>r</em><em>o</em><em>o</em><em>t</em>(<em>b</em><em>i</em><em>n</em>(<em>x</em>,<em>t</em>,<em>y</em>)) = <em>t</em></span></li>
<li><span class="math inline"><em>e</em><em>m</em><em>p</em><em>t</em><em>y</em>(<em>n</em><em>e</em><em>w</em>()) = <em>t</em><em>r</em><em>u</em><em>e</em></span></li>
<li><span class="math inline"><em>e</em><em>m</em><em>p</em><em>t</em><em>y</em>(<em>b</em><em>i</em><em>n</em>(<em>x</em>,<em>t</em>,<em>y</em>))) = <em>f</em><em>a</em><em>l</em><em>s</em><em>e</em></span></li>
</ul></li>
</ul>
</body>
</html>
